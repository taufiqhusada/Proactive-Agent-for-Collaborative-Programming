"""
Real-time AI Agent Service using OpenAI Realtime API
Provides low-latency voice interaction for pair programming
"""

import os
import json
import asyncio
import websockets
import base64
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional, Callable
from dataclasses import dataclass
import threading
import time
import logging

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class Message:
    id: str
    content: str
    username: str
    userId: str
    timestamp: str
    room: str
    isAutoGenerated: bool = False

@dataclass
class ConversationContext:
    messages: List[Message]
    room_id: str
    last_ai_response: Optional[datetime] = None
    code_context: str = ""
    programming_language: str = "python"
    problem_description: str = ""
    problem_title: str = ""

class RealtimeAIAgent:
    def __init__(self, socketio_instance):
        # Check if OpenAI API key is available
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            logger.warning("⚠️  No OpenAI API key found. AI agent will be disabled.")
            logger.warning("   Set OPENAI_API_KEY in your .env file to enable AI responses.")
            self.api_key = None
        else:
            self.api_key = api_key
            logger.info("✅ Realtime AI Agent (CodeBot) initialized successfully!")
        
        self.socketio = socketio_instance
        self.conversation_history = {}  # room_id -> ConversationContext
        self.response_cooldown = 10  # Reduced due to faster responses
        self.min_messages_before_response = 2  # Reduced for more responsive interaction
        self.max_context_messages = 8  # Reduced for faster processing
        
        # AI Agent identity
        self.agent_name = "CodeBot"
        self.agent_id = "ai_agent_codebot"
        
        # Realtime API configuration
        self.realtime_config = {
            "model": "gpt-4o-realtime-preview-2024-10-01",
            "voice": "nova",  # alloy, echo, fable, onyx, nova, shimmer
            "modalities": ["text", "audio"],
            "instructions": self._get_base_instructions(),
            "input_audio_format": "pcm16",
            "output_audio_format": "pcm16",
            "input_audio_transcription": {
                "model": "whisper-1"
            },
            "turn_detection": {
                "type": "server_vad",
                "threshold": 0.5,
                "prefix_padding_ms": 300,
                "silence_duration_ms": 500
            },
            "tools": [
                {
                    "type": "function",
                    "name": "get_code_context",
                    "description": "Get the current code being worked on",
                    "parameters": {
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                },
                {
                    "type": "function", 
                    "name": "get_problem_context",
                    "description": "Get the current programming problem details",
                    "parameters": {
                        "type": "object",
                        "properties": {},
                        "required": []
                    }
                }
            ]
        }
        
        # Active connections: room_id -> websocket
        self.active_connections = {}
        self.connection_tasks = {}
        
    def _get_base_instructions(self) -> str:
        return """You are CodeBot, an AI pair programming assistant. You're working with a team of programmers collaborating on code.

Your role:
- Help solve programming problems and debug issues
- Provide helpful insights and suggestions  
- Answer questions about code, debugging, or programming concepts
- Suggest improvements or alternative approaches
- Be encouraging and collaborative
- Keep responses concise (under 50 words for voice responses)
- Only respond when you can add genuine value

You have access to:
- Current code context via get_code_context()
- Problem details via get_problem_context()
- Recent conversation history

Respond naturally as a helpful teammate. Use voice for quick responses, text for complex explanations."""

    def _get_session_instructions(self, room_id: str) -> str:
        """Get context-aware instructions for a specific room"""
        if room_id not in self.conversation_history:
            return self._get_base_instructions()
            
        context = self.conversation_history[room_id]
        
        instructions = self._get_base_instructions()
        
        if context.problem_title:
            instructions += f"\n\nCurrent problem: {context.problem_title}"
        if context.programming_language:
            instructions += f"\nProgramming language: {context.programming_language}"
        if context.code_context:
            instructions += f"\nCode context available: Yes (use get_code_context() for details)"
            
        return instructions

    async def create_realtime_session(self, room_id: str):
        """Create a new Realtime API session for a room"""
        if not self.api_key:
            logger.warning(f"Cannot create session for room {room_id}: No API key")
            return None
            
        try:
            # WebSocket URL for Realtime API
            url = "wss://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview-2024-10-01"
            
            headers = {
                "Authorization": f"Bearer {self.api_key}",
                "OpenAI-Beta": "realtime=v1"
            }
            
            # Connect to Realtime API
            websocket = await websockets.connect(url, extra_headers=headers)
            
            # Send session configuration
            session_config = {
                "type": "session.update",
                "session": {
                    **self.realtime_config,
                    "instructions": self._get_session_instructions(room_id)
                }
            }
            
            await websocket.send(json.dumps(session_config))
            
            # Store connection
            self.active_connections[room_id] = websocket
            
            # Start message handler
            task = asyncio.create_task(self._handle_realtime_messages(room_id, websocket))
            self.connection_tasks[room_id] = task
            
            logger.info(f"✅ Realtime session created for room {room_id}")
            return websocket
            
        except Exception as e:
            logger.error(f"Failed to create realtime session for room {room_id}: {e}")
            return None

    async def _handle_realtime_messages(self, room_id: str, websocket):
        """Handle incoming messages from Realtime API"""
        try:
            async for message in websocket:
                try:
                    data = json.loads(message)
                    await self._process_realtime_event(room_id, data)
                except json.JSONDecodeError:
                    logger.error(f"Invalid JSON from Realtime API: {message}")
                except Exception as e:
                    logger.error(f"Error processing realtime event: {e}")
                    
        except websockets.exceptions.ConnectionClosed:
            logger.info(f"Realtime connection closed for room {room_id}")
        except Exception as e:
            logger.error(f"Error in realtime message handler for room {room_id}: {e}")
        finally:
            # Cleanup
            if room_id in self.active_connections:
                del self.active_connections[room_id]
            if room_id in self.connection_tasks:
                del self.connection_tasks[room_id]

    async def _process_realtime_event(self, room_id: str, event: Dict[str, Any]):
        """Process events from the Realtime API"""
        event_type = event.get("type")
        
        if event_type == "response.audio.delta":
            # Stream audio chunks to frontend
            audio_data = event.get("delta", "")
            if audio_data:
                self.socketio.emit('ai_audio_chunk', {
                    'audioData': audio_data,
                    'room': room_id
                }, room=room_id, namespace='/ws')
                
        elif event_type == "response.audio.done":
            # Audio response complete
            self.socketio.emit('ai_audio_complete', {
                'room': room_id
            }, room=room_id, namespace='/ws')
            
        elif event_type == "response.text.delta":
            # Stream text chunks to frontend
            text_data = event.get("delta", "")
            if text_data:
                self.socketio.emit('ai_text_chunk', {
                    'textData': text_data,
                    'room': room_id
                }, room=room_id, namespace='/ws')
                
        elif event_type == "response.text.done":
            # Text response complete - send as chat message
            response_id = event.get("response", {}).get("id", "")
            text_content = event.get("text", "")
            
            if text_content:
                message = {
                    'id': f"ai_realtime_{int(time.time() * 1000)}",
                    'content': text_content,
                    'username': self.agent_name,
                    'userId': self.agent_id,
                    'timestamp': datetime.now().isoformat(),
                    'room': room_id,
                    'isAI': True,
                    'hasAudio': True,
                    'isRealtime': True
                }
                
                # Update last response time
                if room_id in self.conversation_history:
                    self.conversation_history[room_id].last_ai_response = datetime.now()
                
                self.socketio.emit('chat_message', message, room=room_id, namespace='/ws')
                
        elif event_type == "response.function_call_arguments.done":
            # Handle function calls
            function_name = event.get("name")
            arguments = event.get("arguments", "{}")
            call_id = event.get("call_id")
            
            if function_name == "get_code_context":
                result = self._get_code_context(room_id)
            elif function_name == "get_problem_context":
                result = self._get_problem_context(room_id)
            else:
                result = {"error": f"Unknown function: {function_name}"}
            
            # Send function result back to API
            function_result = {
                "type": "conversation.item.create",
                "item": {
                    "type": "function_call_output",
                    "call_id": call_id,
                    "output": json.dumps(result)
                }
            }
            
            websocket = self.active_connections.get(room_id)
            if websocket:
                await websocket.send(json.dumps(function_result))
                
        elif event_type == "error":
            logger.error(f"Realtime API error for room {room_id}: {event}")

    def _get_code_context(self, room_id: str) -> Dict[str, Any]:
        """Get current code context for function calls"""
        if room_id not in self.conversation_history:
            return {"code": None, "language": "unknown"}
            
        context = self.conversation_history[room_id]
        return {
            "code": context.code_context[:1000] if context.code_context else None,
            "language": context.programming_language,
            "length": len(context.code_context) if context.code_context else 0
        }

    def _get_problem_context(self, room_id: str) -> Dict[str, Any]:
        """Get current problem context for function calls"""
        if room_id not in self.conversation_history:
            return {"title": None, "description": None}
            
        context = self.conversation_history[room_id]
        return {
            "title": context.problem_title,
            "description": context.problem_description,
            "language": context.programming_language
        }

    async def send_audio_to_realtime(self, room_id: str, audio_data: str):
        """Send audio input to Realtime API"""
        websocket = self.active_connections.get(room_id)
        if not websocket:
            logger.warning(f"No realtime connection for room {room_id}")
            return
            
        try:
            # Send audio input event
            audio_event = {
                "type": "input_audio_buffer.append",
                "audio": audio_data  # Base64 encoded PCM16 audio
            }
            
            await websocket.send(json.dumps(audio_event))
            
            # Commit the audio buffer
            commit_event = {
                "type": "input_audio_buffer.commit"
            }
            
            await websocket.send(json.dumps(commit_event))
            
        except Exception as e:
            logger.error(f"Error sending audio to realtime API: {e}")

    async def send_text_to_realtime(self, room_id: str, text: str):
        """Send text input to Realtime API"""
        websocket = self.active_connections.get(room_id)
        if not websocket:
            logger.warning(f"No realtime connection for room {room_id}")
            return
            
        try:
            # Create conversation item
            text_event = {
                "type": "conversation.item.create",
                "item": {
                    "type": "message",
                    "role": "user",
                    "content": [
                        {
                            "type": "input_text",
                            "text": text
                        }
                    ]
                }
            }
            
            await websocket.send(json.dumps(text_event))
            
            # Create response
            response_event = {
                "type": "response.create",
                "response": {
                    "modalities": ["text", "audio"]
                }
            }
            
            await websocket.send(json.dumps(response_event))
            
        except Exception as e:
            logger.error(f"Error sending text to realtime API: {e}")

    # Legacy compatibility methods
    def add_message_to_context(self, message_data: Dict[str, Any]):
        """Add a new message to the conversation context"""
        room_id = message_data.get('room')
        if not room_id:
            return
            
        # Skip AI's own messages
        if message_data.get('userId') == self.agent_id:
            return
            
        message = Message(
            id=message_data.get('id', ''),
            content=message_data.get('content', ''),
            username=message_data.get('username', 'Unknown'),
            userId=message_data.get('userId', ''),
            timestamp=message_data.get('timestamp', ''),
            room=room_id,
            isAutoGenerated=message_data.get('isAutoGenerated', False)
        )
        
        if room_id not in self.conversation_history:
            self.conversation_history[room_id] = ConversationContext(
                messages=[],
                room_id=room_id
            )
            
        context = self.conversation_history[room_id]
        context.messages.append(message)
        
        # Keep only the most recent messages
        if len(context.messages) > self.max_context_messages:
            context.messages = context.messages[-self.max_context_messages:]
        
        # Send message to realtime API if connection exists
        websocket = self.active_connections.get(room_id)
        if websocket and message.content:
            # Send as text input for context
            asyncio.create_task(self.send_text_to_realtime(room_id, f"{message.username}: {message.content}"))

    def update_code_context(self, room_id: str, code: str, language: str = "python"):
        """Update the current code context for a room"""
        if room_id not in self.conversation_history:
            self.conversation_history[room_id] = ConversationContext(
                messages=[],
                room_id=room_id
            )
            
        context = self.conversation_history[room_id]
        context.code_context = code
        context.programming_language = language
        
        # Update session instructions if connection exists
        websocket = self.active_connections.get(room_id)
        if websocket:
            asyncio.create_task(self._update_session_instructions(room_id))

    def update_problem_context(self, room_id: str, problem_title: str, problem_description: str):
        """Update the current problem description for a room"""
        if room_id not in self.conversation_history:
            self.conversation_history[room_id] = ConversationContext(
                messages=[],
                room_id=room_id
            )
            
        context = self.conversation_history[room_id]
        context.problem_title = problem_title
        context.problem_description = problem_description
        
        # Update session instructions if connection exists
        websocket = self.active_connections.get(room_id)
        if websocket:
            asyncio.create_task(self._update_session_instructions(room_id))

    async def _update_session_instructions(self, room_id: str):
        """Update session instructions with current context"""
        websocket = self.active_connections.get(room_id)
        if not websocket:
            return
            
        try:
            update_event = {
                "type": "session.update",
                "session": {
                    "instructions": self._get_session_instructions(room_id)
                }
            }
            
            await websocket.send(json.dumps(update_event))
            
        except Exception as e:
            logger.error(f"Error updating session instructions: {e}")

    def join_room(self, room_id: str):
        """AI agent joins a room - creates realtime session"""
        if not self.api_key:
            logger.warning(f"⚠️  CodeBot cannot join room {room_id}: No API key")
            return
            
        # Create realtime session in background
        def create_session():
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            
            async def setup():
                websocket = await self.create_realtime_session(room_id)
                if websocket:
                    # Send initial greeting via text
                    await asyncio.sleep(2)  # Brief delay
                    greeting = "Hi! I'm CodeBot, your AI pair programming assistant. I can now respond with voice! Ask me anything about your code."
                    await self.send_text_to_realtime(room_id, greeting)
            
            loop.run_until_complete(setup())
            
        threading.Thread(target=create_session, daemon=True).start()

    def leave_room(self, room_id: str):
        """Clean up when leaving a room"""
        if room_id in self.connection_tasks:
            task = self.connection_tasks[room_id]
            task.cancel()
            
        if room_id in self.active_connections:
            websocket = self.active_connections[room_id]
            asyncio.create_task(websocket.close())

    # Backward compatibility methods (simplified)
    def should_respond(self, room_id: str) -> bool:
        """Realtime API handles response decisions automatically"""
        return False  # Realtime API manages this
        
    async def generate_response(self, room_id: str) -> Optional[str]:
        """Realtime API handles response generation automatically"""
        return None  # Realtime API manages this
        
    def send_ai_message(self, room_id: str, content: str):
        """Send message via Realtime API"""
        asyncio.create_task(self.send_text_to_realtime(room_id, content))
        
    def send_ai_message_text_only(self, room_id: str, content: str):
        """Send text-only message via Realtime API"""
        asyncio.create_task(self.send_text_to_realtime(room_id, content))

    async def process_message(self, message_data: Dict[str, Any]):
        """Process message - just add to context (Realtime API handles responses)"""
        self.add_message_to_context(message_data)
        
    def process_message_sync(self, message_data: Dict[str, Any]):
        """Synchronous wrapper for processing messages"""
        self.add_message_to_context(message_data)

    def handle_code_update(self, room_id: str, code: str, language: str = "python"):
        """Handle code updates from the editor"""
        self.update_code_context(room_id, code, language)
        
    def handle_problem_update(self, room_id: str, problem_title: str, problem_description: str):
        """Handle problem description updates"""
        self.update_problem_context(room_id, problem_title, problem_description)

    def set_voice_config(self, voice: str = None, model: str = None, speed: float = None):
        """Update voice configuration for Realtime API"""
        if voice and voice in ["alloy", "echo", "fable", "onyx", "nova", "shimmer"]:
            self.realtime_config["voice"] = voice
            logger.info(f"Voice updated to: {voice}")

# Global AI agent instance
ai_agent = None

def init_ai_agent(socketio_instance):
    """Initialize the Realtime AI agent"""
    global ai_agent
    ai_agent = RealtimeAIAgent(socketio_instance)
    return ai_agent

def get_ai_agent():
    """Get the global AI agent instance"""
    return ai_agent
