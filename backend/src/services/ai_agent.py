"""
AI Agent Service - A proactive AI teammate for pair programming
Uses GPT-4o-mini to analyze conversations and provide helpful insights
"""

import os
import json
import asyncio
from datetime import datetime, timedelta
from typing import List, Dict, Any, Optional
from openai import OpenAI
from dataclasses import dataclass
import threading
import time

@dataclass
class Message:
    id: str
    content: str
    username: str
    userId: str
    timestamp: str
    room: str
    isAutoGenerated: bool = False

@dataclass
class ConversationContext:
    messages: List[Message]
    room_id: str
    last_ai_response: Optional[datetime] = None
    code_context: str = ""
    programming_language: str = "python"
    problem_description: str = ""
    problem_title: str = ""

class AIAgent:
    def __init__(self, socketio_instance):
        # Check if OpenAI API key is available
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            print("⚠️  Warning: No OpenAI API key found. AI agent will be disabled.")
            print("   Set OPENAI_API_KEY in your .env file to enable AI responses.")
            self.client = None
        else:
            try:
                self.client = OpenAI(api_key=api_key)
                print("✅ AI Agent (CodeBot) initialized successfully!")
            except Exception as e:
                print(f"❌ Error initializing OpenAI client: {e}")
                print("   AI agent will be disabled.")
                self.client = None
        
        self.socketio = socketio_instance
        self.conversation_history = {}  # room_id -> ConversationContext
        self.response_cooldown = 15  # Minimum seconds between AI responses
        self.min_messages_before_response = 3  # Wait for at least 3 messages before responding
        self.max_context_messages = 10  # Keep last 10 messages for context
        
        # AI Agent identity and voice configuration
        self.agent_name = "CodeBot"
        self.agent_id = "ai_agent_codebot"
        self.voice_config = {
            "model": "tts-1",  # Use tts-1 for speed, tts-1-hd for quality
            "voice": "nova",   # Available: alloy, echo, fable, onyx, nova, shimmer
            "speed": 1.1       # 0.25 to 4.0
        }
        
    def add_message_to_context(self, message_data: Dict[str, Any]):
        """Add a new message to the conversation context"""
        room_id = message_data.get('room')
        if not room_id:
            return
            
        # Skip AI's own messages
        if message_data.get('userId') == self.agent_id:
            return
            
        message = Message(
            id=message_data.get('id', ''),
            content=message_data.get('content', ''),
            username=message_data.get('username', 'Unknown'),
            userId=message_data.get('userId', ''),
            timestamp=message_data.get('timestamp', ''),
            room=room_id,
            isAutoGenerated=message_data.get('isAutoGenerated', False)
        )
        
        if room_id not in self.conversation_history:
            self.conversation_history[room_id] = ConversationContext(
                messages=[],
                room_id=room_id
            )
            
        context = self.conversation_history[room_id]
        context.messages.append(message)
        
        # Keep only the most recent messages
        if len(context.messages) > self.max_context_messages:
            context.messages = context.messages[-self.max_context_messages:]
            
    def update_code_context(self, room_id: str, code: str, language: str = "python"):
        """Update the current code context for a room"""
        if room_id not in self.conversation_history:
            self.conversation_history[room_id] = ConversationContext(
                messages=[],
                room_id=room_id
            )
            
        context = self.conversation_history[room_id]
        context.code_context = code
        context.programming_language = language
        
    def update_problem_context(self, room_id: str, problem_title: str, problem_description: str):
        """Update the current problem description for a room"""
        if room_id not in self.conversation_history:
            self.conversation_history[room_id] = ConversationContext(
                messages=[],
                room_id=room_id
            )
            
        context = self.conversation_history[room_id]
        context.problem_title = problem_title
        context.problem_description = problem_description
        print(f"Updated problem context for room {room_id}: {problem_title}")

    def should_respond(self, room_id: str) -> bool:
        """Determine if the AI should respond based on various factors"""
        if room_id not in self.conversation_history:
            return False
            
        context = self.conversation_history[room_id]

        # Check cooldown period
        if context.last_ai_response:
            time_since_last = datetime.now() - context.last_ai_response
            if time_since_last < timedelta(seconds=self.response_cooldown):
                return False
                
        # Need minimum number of messages
        if len(context.messages) < self.min_messages_before_response:
            return False
            
        # Check if recent messages warrant a response
        recent_messages = context.messages[-3:]  # Last 3 messages
        
        # Keywords that might indicate need for help
        help_keywords = [
            'error', 'bug', 'problem', 'issue', 'stuck', 'help', 'question',
            'why', 'how', 'what', 'debug', 'fix', 'broken', 'fail', 'exception',
            'syntax', 'logic', 'algorithm', 'optimize', 'improve', 'better way',
            'confused', 'understand', 'explain', 'clarify'
        ]
        
        # Programming-related keywords
        programming_keywords = [
            'function', 'class', 'method', 'variable', 'loop', 'condition',
            'array', 'list', 'dict', 'object', 'import', 'library', 'module',
            'api', 'database', 'query', 'test', 'unittest', 'framework'
        ]
        
        for message in recent_messages:
            content_lower = message.content.lower()
            
            # Direct questions or help requests
            if any(keyword in content_lower for keyword in help_keywords):
                return True
                
            # Programming discussions
            if any(keyword in content_lower for keyword in programming_keywords):
                return True
                
            # Questions (contain question marks)
            if '?' in message.content:
                return True
                
        return False
        
    async def generate_response(self, room_id: str) -> Optional[str]:
        """Generate an AI response based on conversation context"""
        if not self.client:
            print("⚠️  Cannot generate AI response: OpenAI client not initialized")
            return None
            
        if room_id not in self.conversation_history:
            return None
            
        context = self.conversation_history[room_id]
        
        # Build conversation history for the prompt
        conversation_text = ""
        for msg in context.messages[-5:]:  # Last 5 messages
            conversation_text += f"{msg.username}: {msg.content}\n"
            

        # Create the system prompt
        system_prompt = f"""You are CodeBot, an AI pair programming assistant. You're working with a team of programmers who are collaborating on code.

                            Current programming problem: {context.problem_title if context.problem_title else "No specific problem"}
                            Problem description: {context.problem_description if context.problem_description else "No problem description available"}

                            Current programming language: {context.programming_language}

                            Current code context:
                            ```{context.programming_language}
                            {context.code_context[:1000] if context.code_context else "No code context available"}
                            ```

                            Recent conversation:
                            {conversation_text}

                            Your role:
                            1. Help solve the current programming problem
                            2. Provide helpful programming insights and suggestions
                            3. Answer questions about code, debugging, or programming concepts
                            4. Suggest improvements or alternative approaches
                            4. Help resolve errors or issues
                            5. Be concise but helpful (keep responses under 70 words maximum)
                            6. Be encouraging and collaborative
                            7. Only respond when you can add genuine value to the conversation

                            Respond naturally as if you're a helpful teammate who has been listening to the conversation. Keep your response very brief and focused. If the conversation doesn't warrant a technical response, you can also provide encouragement or ask clarifying questions.
                            """

        try:
            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"Based on the recent conversation, provide a helpful response as CodeBot in 70 words or less. If the conversation doesn't need a technical response, you can skip responding by saying 'SKIP_RESPONSE'."}
                ],
                max_tokens=80,  # Reduced to ensure ~70 words max
                temperature=0.7
            )
            
            print(system_prompt)
            ai_response = response.choices[0].message.content.strip()
            print(ai_response)
            
            # Check if AI decided not to respond
            if ai_response == "SKIP_RESPONSE" or not ai_response:
                return None
            
            # Ensure response doesn't exceed 70 words
            words = ai_response.split()
            if len(words) > 70:
                ai_response = ' '.join(words[:70]) + "..."
                print(f"Truncated response to 70 words: {ai_response}")
                
            return ai_response
            
        except Exception as e:
            print(f"Error generating AI response: {e}")
            return None
            
    async def generate_speech(self, text: str) -> Optional[bytes]:
        """Generate speech audio from text using OpenAI TTS"""
        if not self.client:
            return None
            
        try:
            # Limit text length to avoid very long audio files (70 words ≈ 350-500 chars)
            if len(text) > 500:
                text = text[:500] + "..."
            
            response = self.client.audio.speech.create(
                model=self.voice_config["model"],
                voice=self.voice_config["voice"],
                input=text,
                speed=self.voice_config["speed"]
            )
            
            # Return the audio bytes
            return response.content
            
        except Exception as e:
            print(f"Error generating speech: {e}")
            return None

    async def send_ai_message_with_audio(self, room_id: str, content: str):
        """Send an AI message to the chat room with optional audio"""
        # Generate audio asynchronously
        audio_data = await self.generate_speech(content)
        
        message = {
            'id': f"ai_{int(time.time() * 1000)}",
            'content': content,
            'username': self.agent_name,
            'userId': self.agent_id,
            'timestamp': datetime.now().isoformat(),
            'room': room_id,
            'isAI': True,
            'hasAudio': audio_data is not None
        }
        
        # Update last response time
        if room_id in self.conversation_history:
            self.conversation_history[room_id].last_ai_response = datetime.now()
            
        # Emit the message to the room
        self.socketio.emit('chat_message', message, room=room_id, namespace='/ws')
        
        # If audio was generated, send it separately
        if audio_data:
            # Convert audio bytes to base64 for transmission
            import base64
            audio_base64 = base64.b64encode(audio_data).decode('utf-8')
            
            self.socketio.emit('ai_speech', {
                'messageId': message['id'],
                'audioData': audio_base64,
                'room': room_id
            }, room=room_id, namespace='/ws')
        
        print(f"AI Agent sent message to room {room_id}: {content} (audio: {'yes' if audio_data else 'no'})")
    
    def send_ai_message_text_only(self, room_id: str, content: str):
        """Send an AI message to the chat room without audio"""
        message = {
            'id': f"ai_{int(time.time() * 1000)}",
            'content': content,
            'username': self.agent_name,
            'userId': self.agent_id,
            'timestamp': datetime.now().isoformat(),
            'room': room_id,
            'isAI': True,
            'hasAudio': False
        }
        
        # Update last response time
        if room_id in self.conversation_history:
            self.conversation_history[room_id].last_ai_response = datetime.now()
            
        # Emit the message to the room (no audio)
        self.socketio.emit('chat_message', message, room=room_id, namespace='/ws')
        print(f"AI Agent sent text-only message to room {room_id}: {content}")
    
    def send_ai_message(self, room_id: str, content: str):
        """Send an AI message to the chat room (sync version for backward compatibility)"""
        try:
            # Check if we're already in an event loop
            try:
                loop = asyncio.get_running_loop()
                # If we're already in an event loop, schedule the coroutine
                asyncio.create_task(self.send_ai_message_with_audio(room_id, content))
                return
            except RuntimeError:
                # No running loop, create a new one
                pass
            
            # Create new event loop
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self.send_ai_message_with_audio(room_id, content))
            loop.close()
        except Exception as e:
            print(f"Error sending AI message with audio: {e}")
            # Fallback to text-only message
            message = {
                'id': f"ai_{int(time.time() * 1000)}",
                'content': content,
                'username': self.agent_name,
                'userId': self.agent_id,
                'timestamp': datetime.now().isoformat(),
                'room': room_id,
                'isAI': True,
                'hasAudio': False
            }
            
            if room_id in self.conversation_history:
                self.conversation_history[room_id].last_ai_response = datetime.now()
                
            self.socketio.emit('chat_message', message, room=room_id, namespace='/ws')
            print(f"AI Agent sent text-only message to room {room_id}: {content}")
        
    async def process_message(self, message_data: Dict[str, Any]):
        """Process a new message and potentially respond"""
        room_id = message_data.get('room')
        if not room_id:
            return
            
        # Add message to context
        self.add_message_to_context(message_data)
        

        # Check if we should respond
        if self.should_respond(room_id):
            print(f"AI should respond in room {room_id}, generating response...")
            # Generate response asynchronously
            response = await self.generate_response(room_id)
            print(f"Generated response for room {room_id}: {response}")
            
            if response:
                # Send the response using async version
                await self.send_ai_message_with_audio(room_id, response)
                
    def process_message_sync(self, message_data: Dict[str, Any]):
        """Synchronous wrapper for processing messages"""
        try:
            # Run the async function in a new event loop
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(self.process_message(message_data))
            loop.close()
        except Exception as e:
            print(f"Error processing message in AI agent: {e}")
            
    def handle_code_update(self, room_id: str, code: str, language: str = "python"):
        """Handle code updates from the editor"""
        self.update_code_context(room_id, code, language)
        
    def handle_problem_update(self, room_id: str, problem_title: str, problem_description: str):
        """Handle problem description updates"""
        self.update_problem_context(room_id, problem_title, problem_description)
        
    def join_room(self, room_id: str):
        """AI agent joins a room"""
        # Only send greeting if OpenAI client is available
        if not self.client:
            print(f"⚠️  CodeBot cannot join room {room_id}: OpenAI client not initialized")
            return
            
        # Send a greeting message when joining
        greeting_messages = [
            "Hi! I'm CodeBot, your proactive AI pair programming teammate. I'll be listening and will jump in if I can help!",
        ]
        
        import random
        greeting = random.choice(greeting_messages)
        
        # Send greeting after a short delay
        def send_greeting():
            time.sleep(2)  # Wait 2 seconds before greeting
            # Use text-only method for greeting to avoid audio on first message
            self.send_ai_message_text_only(room_id, greeting)
            
        threading.Thread(target=send_greeting, daemon=True).start()

    def set_voice_config(self, voice: str = None, model: str = None, speed: float = None):
        """Update voice configuration for TTS"""
        if voice and voice in ["alloy", "echo", "fable", "onyx", "nova", "shimmer"]:
            self.voice_config["voice"] = voice
        if model and model in ["tts-1", "tts-1-hd"]:
            self.voice_config["model"] = model
        if speed and 0.25 <= speed <= 4.0:
            self.voice_config["speed"] = speed
        
        print(f"Voice config updated: {self.voice_config}")

# Global AI agent instance
ai_agent = None

def init_ai_agent(socketio_instance):
    """Initialize the AI agent"""
    global ai_agent
    ai_agent = AIAgent(socketio_instance)
    return ai_agent

def get_ai_agent():
    """Get the global AI agent instance"""
    return ai_agent
