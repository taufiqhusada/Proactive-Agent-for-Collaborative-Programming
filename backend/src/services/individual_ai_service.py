"""
Individual AI Service - Handles personal AI assistant functionality
Provides private AI interactions for each user in individual mode
"""

import os
import uuid
from datetime import datetime
from typing import Dict, List, Optional

from openai import OpenAI

from .ai_models import Message
from .ai_agent import get_ai_agent


class IndividualAIService:
    def __init__(self, socketio_instance):
        # Check if OpenAI API key is available
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            print("âš ï¸  Warning: No OpenAI API key found. Individual AI will be disabled.")
            self.client = None
        else:
            try:
                self.client = OpenAI(api_key=api_key)
                print("âœ… Individual AI Service initialized successfully!")
            except Exception as e:
                print(f"âŒ Error initializing OpenAI client for Individual AI: {e}")
                self.client = None
        
        self.socketio = socketio_instance
        
        # Store individual conversations: {user_id: {room_id: [messages]}}
        self.individual_conversations = {}
        
        # AI Assistant identity for individual mode
        self.assistant_name = "AI Assistant"
        self.assistant_id = "individual_ai_assistant"

    def handle_individual_message_sync(self, user_id: str, room_id: str, message_content: str) -> Optional[str]:
        """Handle individual AI message synchronously and return response"""
        if not self.client:
            print("ðŸš« AI service not available")
            return None

        try:
            # Initialize user conversation if not exists
            if user_id not in self.individual_conversations:
                self.individual_conversations[user_id] = {}
            
            if room_id not in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []

            # Add user message to conversation history
            user_message = Message(
                id=f"user_{user_id}_{len(self.individual_conversations[user_id][room_id])}_user",
                username="User",
                content=message_content,
                userId=user_id,
                timestamp=datetime.now().isoformat(),
                room=room_id,
                isAutoGenerated=False
            )
            self.individual_conversations[user_id][room_id].append(user_message)

            # Generate AI response
            ai_response = self._generate_individual_response(user_id, room_id, message_content)
            
            if ai_response:
                # Add AI response to conversation history
                ai_message = Message(
                    id=f"ai_{user_id}_{len(self.individual_conversations[user_id][room_id])}_ai",
                    username=self.assistant_name,
                    content=ai_response,
                    userId=self.assistant_id,
                    timestamp=datetime.now().isoformat(),
                    room=room_id,
                    isAutoGenerated=True
                )
                self.individual_conversations[user_id][room_id].append(ai_message)
                return ai_response
            else:
                return None

        except Exception as e:
            print(f"âŒ Error handling individual message for user {user_id}: {e}")
            return None

    def handle_individual_message(self, user_id: str, room_id: str, message_content: str, message_id: str = None):
        """Handle a message from a user to their individual AI assistant (legacy socket version)"""
        if not self.client:
            self._send_error_response(user_id, "AI service is not available")
            return

        try:
            # Initialize user conversation if not exists
            if user_id not in self.individual_conversations:
                self.individual_conversations[user_id] = {}
            
            if room_id not in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []

            # Add user message to conversation history
            user_message = Message(
                id=f"user_{user_id}_{len(self.individual_conversations[user_id][room_id])}_user",
                username="User",
                content=message_content,
                userId=user_id,
                timestamp=datetime.now().isoformat(),
                room=room_id,
                isAutoGenerated=False
            )
            self.individual_conversations[user_id][room_id].append(user_message)

            # Generate AI response
            ai_response = self._generate_individual_response(user_id, room_id, message_content)
            
            if ai_response:
                # Add AI response to conversation history
                ai_message = Message(
                    id=f"ai_{user_id}_{len(self.individual_conversations[user_id][room_id])}_ai",
                    username=self.assistant_name,
                    content=ai_response,
                    userId=self.assistant_id,
                    timestamp=datetime.now().isoformat(),
                    room=room_id,
                    isAutoGenerated=True
                )
                self.individual_conversations[user_id][room_id].append(ai_message)

                # Send response back to the specific user
                self._send_individual_response(user_id, ai_response, message_id)
            else:
                self._send_error_response(user_id, "Failed to generate AI response")

        except Exception as e:
            print(f"âŒ Error handling individual message for user {user_id}: {e}")
            self._send_error_response(user_id, "An error occurred while processing your message")

    def _generate_individual_response(self, user_id: str, room_id: str, message_content: str) -> Optional[str]:
        """Generate AI response for individual conversation"""
        try:
            # Get conversation history
            conversation_history = self.individual_conversations[user_id][room_id]
            
            # Build conversation context for the prompt
            conversation_context = ""
            for msg in conversation_history[-10:]:  # Last 10 messages
                # Use isAutoGenerated to determine if it's an AI message
                role = "Assistant" if msg.isAutoGenerated else "User"
                conversation_context += f"{role}: {msg.content}\n"

            # Get problem and code context from the main AI agent
            problem_context = ""
            code_context = ""
            
            ai_agent = get_ai_agent()
            if ai_agent and room_id in ai_agent.conversation_history:
                main_context = ai_agent.conversation_history[room_id]
                if main_context.problem_title or main_context.problem_description:
                    problem_context = f"""
Current Problem:
- Title: {main_context.problem_title or "Not specified"}
- Description: {main_context.problem_description or "Not specified"}
- Language: {main_context.programming_language or "Not specified"}
"""
                
                if main_context.code_context:
                    # Show relevant portion of code (first 500 chars)
                    code_snippet = main_context.code_context[:500]
                    if len(main_context.code_context) > 500:
                        code_snippet += "..."
                    code_context = f"""
Current Code:
```{main_context.programming_language or 'python'}
{code_snippet}
```
"""

            prompt = f"""You are a helpful AI programming assistant focused on LEARNING. You are having a private conversation with a user during their pair programming session.

        Context: The user is working on a coding problem with their teammate(s). This is a private conversation between you and this specific user - other team members cannot see this chat.
        {problem_context}
        {code_context}
        Conversation History:
        {conversation_context}

     NATURAL TEACHING APPROACH - Be helpful while encouraging learning:
    - Mix different response types: hints, encouragement, specific guidance, questions
    - Be conversational and supportive, not just question-asking
    - Adapt to their level: sometimes give direct help when appropriate
    - Balance learning with actually being helpful
    - If they have execution results, focus on those specific issues

    IMPORTANT: Be naturally helpful while encouraging learning
    Response format:natural, helpful response that may include hints, tips, or direct guidance - 15-40 words
      

    Respond to the user's latest message with helpful hints or guidance:"""

            print("Generating individual AI response...", prompt)

            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": prompt}
                ],
                max_tokens=150,
                temperature=0.7
            )
            
            return response.choices[0].message.content.strip()

        except Exception as e:
            print(f"âŒ Error generating individual AI response: {e}")
            return None

    def _send_individual_response(self, user_id: str, response: str, original_message_id: str = None):
        """Send AI response to the specific user"""
        self.socketio.emit('individual_ai_response', {
            'userId': user_id,
            'response': response,
            'messageId': original_message_id,
            'timestamp': datetime.now().isoformat()
        })

    def _send_error_response(self, user_id: str, error_message: str):
        """Send error response to the specific user"""
        self.socketio.emit('individual_ai_response', {
            'userId': user_id,
            'response': f"Sorry, {error_message}. Please try again.",
            'isError': True,
            'timestamp': datetime.now().isoformat()
        })

    def clear_individual_conversation(self, user_id: str, room_id: str):
        """Clear conversation history for a specific user in a room"""
        if user_id in self.individual_conversations:
            if room_id in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []
                print(f"ðŸ§¹ Cleared individual conversation for user {user_id} in room {room_id}")

    def clear_room_conversations(self, room_id: str):
        """Clear all individual conversations for a specific room"""
        users_cleared = 0
        for user_id in list(self.individual_conversations.keys()):
            if room_id in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []
                users_cleared += 1
        print(f"ðŸ§¹ Cleared individual AI conversations for {users_cleared} users in room {room_id}")

    def get_conversation_history(self, user_id: str, room_id: str) -> List[Message]:
        """Get conversation history for a specific user in a room"""
        if user_id in self.individual_conversations:
            if room_id in self.individual_conversations[user_id]:
                return self.individual_conversations[user_id][room_id]
        return []

    def handle_user_disconnect(self, user_id: str):
        """Clean up when user disconnects"""
        if user_id in self.individual_conversations:
            # Keep conversation history but could implement cleanup logic here
            print(f"ðŸ‘‹ User {user_id} disconnected from individual AI service")


# Global service instance
individual_ai_service = None

def init_individual_ai_service(socketio_instance):
    """Initialize the individual AI service"""
    global individual_ai_service
    individual_ai_service = IndividualAIService(socketio_instance)
    return individual_ai_service

def get_individual_ai_service():
    """Get the global individual AI service instance"""
    return individual_ai_service
