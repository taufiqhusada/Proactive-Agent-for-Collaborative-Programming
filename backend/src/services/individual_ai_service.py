"""
Individual AI Service - Handles personal AI assistant functionality
Provides private AI interactions for each user in individual mode by using separate room IDs
"""

import os
import uuid
from datetime import datetime
from typing import Dict, List, Optional

from .ai_agent import get_ai_agent


class IndividualAIService:
    def __init__(self, socketio_instance):
        self.socketio = socketio_instance
        
        # Store mapping of personal rooms to original rooms for cleanup
        # Format: {personal_room_id: original_room_id}
        self.personal_room_mapping = {}
        
        print("‚úÖ Individual AI Service initialized (using core AI agent)!")

    def get_personal_room_id(self, original_room_id: str, user_id: str) -> str:
        """Generate personal room ID for a user"""
        personal_room = f"{original_room_id}_personal_{user_id}"
        self.personal_room_mapping[personal_room] = original_room_id
        return personal_room

    def handle_individual_message_sync(self, user_id: str, room_id: str, message_content: str) -> Optional[str]:
        """Handle individual AI message synchronously using core AI agent"""
        try:
            print(f"ü§ñ Individual AI Service: Starting to handle message from user {user_id} in room {room_id}")
            print(f"ü§ñ Message content: {message_content[:100]}...")
            
            ai_agent = get_ai_agent()
            if not ai_agent or not ai_agent.client:
                print("üö´ Core AI agent not available")
                return None

            # Generate personal room ID
            personal_room_id = self.get_personal_room_id(room_id, user_id)
            print(f"ü§ñ Processing individual message for personal room: {personal_room_id}")

            # Create message data for the core AI agent
            message_data = {
                'id': f"user_{int(datetime.now().timestamp() * 1000)}",
                'content': message_content,
                'username': 'You',
                'userId': user_id,
                'timestamp': datetime.now().isoformat(),
                'room': personal_room_id,
                'isAutoGenerated': False
            }

            print(f"ü§ñ Adding user message to AI agent context: {message_data}")
            
            # Add the user message to the core AI's conversation context
            ai_agent.add_message_to_context(message_data)

            print(f"ü§ñ Calling centralized AI decision for personal room: {personal_room_id}")
            
            # Generate response using the core AI's decision making
            should_respond, ai_response = ai_agent._centralized_ai_decision(personal_room_id)
            
            print(f"ü§ñ AI decision result - should_respond: {should_respond}, response length: {len(ai_response) if ai_response else 0}")
            
            if should_respond and ai_response:
                print(f"ü§ñ AI will respond with: {ai_response[:100]}...")
                
                # Create AI message data
                ai_message_data = {
                    'id': f"ai_{int(datetime.now().timestamp() * 1000)}",
                    'content': ai_response,
                    'username': ai_agent.agent_name,
                    'userId': ai_agent.agent_id,
                    'timestamp': datetime.now().isoformat(),
                    'room': personal_room_id,
                    'isAutoGenerated': True
                }
                
                # Add AI response to context
                ai_agent.add_message_to_context(ai_message_data)
                
                return ai_response
            else:
                # For personal AI, we should always try to respond
                print("ü§ñ AI decided not to respond, providing fallback response")
                fallback_response = "I'm here to help! Feel free to ask me anything about your code or the problem you're working on."
                
                ai_message_data = {
                    'id': f"ai_{int(datetime.now().timestamp() * 1000)}",
                    'content': fallback_response,
                    'username': ai_agent.agent_name,
                    'userId': ai_agent.agent_id,
                    'timestamp': datetime.now().isoformat(),
                    'room': personal_room_id,
                    'isAutoGenerated': True
                }
                
                ai_agent.add_message_to_context(ai_message_data)
                return fallback_response

        except Exception as e:
            print(f"‚ùå Error handling individual message for user {user_id}: {e}")
            import traceback
            traceback.print_exc()
            return None

    def handle_individual_message(self, user_id: str, room_id: str, message_content: str, message_id: str = None):
        """Handle a message from a user to their individual AI assistant (legacy socket version)"""
        ai_response = self.handle_individual_message_sync(user_id, room_id, message_content)
        
        if ai_response:
            # Send response back to the specific user
            self._send_individual_response(user_id, ai_response, message_id)
        else:
            self._send_error_response(user_id, "Failed to generate AI response")

    def _send_individual_response(self, user_id: str, response: str, original_message_id: str = None):
        """Send AI response to the specific user"""
        self.socketio.emit('individual_ai_response', {
            'userId': user_id,
            'response': response,
            'messageId': original_message_id,
            'timestamp': datetime.now().isoformat()
        })

    def _send_error_response(self, user_id: str, error_message: str):
        """Send error response to the specific user"""
        self.socketio.emit('individual_ai_response', {
            'userId': user_id,
            'response': f"Sorry, {error_message}. Please try again.",
            'isError': True,
            'timestamp': datetime.now().isoformat()
        })

    def copy_room_context_to_personal(self, original_room_id: str, user_id: str):
        """Copy context from original room to personal room for better AI responses"""
        try:
            ai_agent = get_ai_agent()
            if not ai_agent:
                return
                
            personal_room_id = self.get_personal_room_id(original_room_id, user_id)
            
            # Get original room context
            original_context = ai_agent.conversation_history.get(original_room_id)
            if not original_context:
                print(f"‚ÑπÔ∏è No original context found for room {original_room_id}")
                return
            
            # Copy problem and code context to personal room
            if personal_room_id not in ai_agent.conversation_history:
                from .ai_models import ConversationContext
                ai_agent.conversation_history[personal_room_id] = ConversationContext(
                    messages=[],
                    room_id=personal_room_id
                )
            
            personal_context = ai_agent.conversation_history[personal_room_id]
            
            # Copy relevant context (but not the conversation history)
            personal_context.problem_title = original_context.problem_title
            personal_context.problem_description = original_context.problem_description
            personal_context.code_context = original_context.code_context
            personal_context.programming_language = original_context.programming_language
            
            print(f"‚úÖ Copied context from {original_room_id} to personal room {personal_room_id}")
            
        except Exception as e:
            print(f"‚ùå Error copying context to personal room: {e}")

    def clear_individual_conversation(self, user_id: str, room_id: str):
        """Clear conversation history for a specific user in a room"""
        try:
            ai_agent = get_ai_agent()
            if not ai_agent:
                return
                
            personal_room_id = self.get_personal_room_id(room_id, user_id)
            
            if personal_room_id in ai_agent.conversation_history:
                del ai_agent.conversation_history[personal_room_id]
                print(f"üßπ Cleared individual conversation for user {user_id} in room {room_id}")
        except Exception as e:
            print(f"‚ùå Error clearing individual conversation: {e}")

    def clear_room_conversations(self, room_id: str):
        """Clear all individual conversations for a specific room"""
        try:
            ai_agent = get_ai_agent()
            if not ai_agent:
                return
                
            users_cleared = 0
            # Find all personal rooms for this original room
            personal_rooms_to_clear = []
            for personal_room, original_room in self.personal_room_mapping.items():
                if original_room == room_id:
                    personal_rooms_to_clear.append(personal_room)
            
            # Clear the personal rooms
            for personal_room in personal_rooms_to_clear:
                if personal_room in ai_agent.conversation_history:
                    del ai_agent.conversation_history[personal_room]
                    users_cleared += 1
                
                # Remove from mapping
                if personal_room in self.personal_room_mapping:
                    del self.personal_room_mapping[personal_room]
            
            print(f"üßπ Cleared individual AI conversations for {users_cleared} users in room {room_id}")
        except Exception as e:
            print(f"‚ùå Error clearing room conversations: {e}")

    def get_conversation_history(self, user_id: str, room_id: str) -> List:
        """Get conversation history for a specific user in a room"""
        try:
            ai_agent = get_ai_agent()
            if not ai_agent:
                return []
                
            personal_room_id = self.get_personal_room_id(room_id, user_id)
            context = ai_agent.conversation_history.get(personal_room_id)
            
            return context.messages if context else []
        except Exception as e:
            print(f"‚ùå Error getting conversation history: {e}")
            return []

    def handle_user_disconnect(self, user_id: str):
        """Handle user disconnect by cleaning up personal rooms"""
        print(f"üëã Cleaning up personal rooms for disconnected user {user_id}")
        # Clean up any personal rooms for this user
        to_remove = [room_id for room_id in self.personal_room_mapping.keys() 
                     if room_id.endswith(f"_personal_{user_id}")]
        for room_id in to_remove:
            del self.personal_room_mapping[room_id]

    def start_panel_analysis_for_user(self, original_room_id: str, user_id: str, code: str, result: dict):
        """Start code execution panel analysis for individual AI mode"""
        try:
            print(f"ÔøΩ Starting individual panel analysis for user {user_id} in room {original_room_id}")
            
            ai_agent = get_ai_agent()
            if not ai_agent or not ai_agent.code_analysis_service:
                print("üö´ Core AI agent or code analysis service not available")
                return
                
            # Generate personal room ID for analysis
            personal_room_id = self.get_personal_room_id(original_room_id, user_id)
            print(f"üîç Using personal room for analysis: {personal_room_id}")
            
            # Use the core AI agent's code analysis service but with personal room ID
            ai_agent.code_analysis_service.start_panel_analysis(
                personal_room_id, 
                code, 
                result, 
                ai_agent.conversation_history
            )
            
            print(f"üîç Started individual panel analysis for personal room: {personal_room_id}")
            
        except Exception as e:
            print(f"‚ùå Error in individual panel analysis for user {user_id}: {e}")


# Global service instance
individual_ai_service = None

def init_individual_ai_service(socketio_instance):
    """Initialize the individual AI service"""
    global individual_ai_service
    individual_ai_service = IndividualAIService(socketio_instance)
    return individual_ai_service

def get_individual_ai_service():
    """Get the global individual AI service instance"""
    return individual_ai_service
