"""
Individual AI Service - Handles personal AI assistant functionality
Provides private AI interactions for each user in individual mode
"""

import os
import uuid
from datetime import datetime
from typing import Dict, List, Optional

from openai import OpenAI

from .ai_models import Message
from .ai_agent import get_ai_agent


class IndividualAIService:
    def __init__(self, socketio_instance):
        # Check if OpenAI API key is available
        api_key = os.getenv("OPENAI_API_KEY")
        if not api_key:
            print("âš ï¸  Warning: No OpenAI API key found. Individual AI will be disabled.")
            self.client = None
        else:
            try:
                self.client = OpenAI(api_key=api_key)
                print("âœ… Individual AI Service initialized successfully!")
            except Exception as e:
                print(f"âŒ Error initializing OpenAI client for Individual AI: {e}")
                self.client = None
        
        self.socketio = socketio_instance
        
        # Store individual conversations: {user_id: {room_id: [messages]}}
        self.individual_conversations = {}
        
        # AI Assistant identity for individual mode
        self.assistant_name = "AI Assistant"
        self.assistant_id = "individual_ai_assistant"

    def handle_individual_message_sync(self, user_id: str, room_id: str, message_content: str) -> Optional[str]:
        """Handle individual AI message synchronously and return response"""
        if not self.client:
            print("ðŸš« AI service not available")
            return None

        try:
            # Initialize user conversation if not exists
            if user_id not in self.individual_conversations:
                self.individual_conversations[user_id] = {}
            
            if room_id not in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []

            # Add user message to conversation history
            user_message = Message(
                id=f"user_{user_id}_{len(self.individual_conversations[user_id][room_id])}_user",
                username="User",
                content=message_content,
                userId=user_id,
                timestamp=datetime.now().isoformat(),
                room=room_id,
                isAutoGenerated=False
            )
            self.individual_conversations[user_id][room_id].append(user_message)

            # Generate AI response
            ai_response = self._generate_individual_response(user_id, room_id, message_content)
            
            if ai_response:
                # Add AI response to conversation history
                ai_message = Message(
                    id=f"ai_{user_id}_{len(self.individual_conversations[user_id][room_id])}_ai",
                    username=self.assistant_name,
                    content=ai_response,
                    userId=self.assistant_id,
                    timestamp=datetime.now().isoformat(),
                    room=room_id,
                    isAutoGenerated=True
                )
                self.individual_conversations[user_id][room_id].append(ai_message)
                return ai_response
            else:
                return None

        except Exception as e:
            print(f"âŒ Error handling individual message for user {user_id}: {e}")
            return None

    def handle_individual_message(self, user_id: str, room_id: str, message_content: str, message_id: str = None):
        """Handle a message from a user to their individual AI assistant (legacy socket version)"""
        if not self.client:
            self._send_error_response(user_id, "AI service is not available")
            return

        try:
            # Initialize user conversation if not exists
            if user_id not in self.individual_conversations:
                self.individual_conversations[user_id] = {}
            
            if room_id not in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []

            # Add user message to conversation history
            user_message = Message(
                id=f"user_{user_id}_{len(self.individual_conversations[user_id][room_id])}_user",
                username="User",
                content=message_content,
                userId=user_id,
                timestamp=datetime.now().isoformat(),
                room=room_id,
                isAutoGenerated=False
            )
            self.individual_conversations[user_id][room_id].append(user_message)

            # Generate AI response
            ai_response = self._generate_individual_response(user_id, room_id, message_content)
            
            if ai_response:
                # Add AI response to conversation history
                ai_message = Message(
                    id=f"ai_{user_id}_{len(self.individual_conversations[user_id][room_id])}_ai",
                    username=self.assistant_name,
                    content=ai_response,
                    userId=self.assistant_id,
                    timestamp=datetime.now().isoformat(),
                    room=room_id,
                    isAutoGenerated=True
                )
                self.individual_conversations[user_id][room_id].append(ai_message)

                # Send response back to the specific user
                self._send_individual_response(user_id, ai_response, message_id)
            else:
                self._send_error_response(user_id, "Failed to generate AI response")

        except Exception as e:
            print(f"âŒ Error handling individual message for user {user_id}: {e}")
            self._send_error_response(user_id, "An error occurred while processing your message")

    def _generate_individual_response(self, user_id: str, room_id: str, message_content: str) -> Optional[str]:
        """Generate AI response for individual conversation"""
        try:
            # Get conversation history
            conversation_history = self.individual_conversations[user_id][room_id]
            
            # Build conversation context for the prompt
            conversation_context = ""
            for msg in conversation_history[-10:]:  # Last 10 messages
                # Use isAutoGenerated to determine if it's an AI message
                role = "Assistant" if msg.isAutoGenerated else "User"
                conversation_context += f"{role}: {msg.content}\n"

            # Get problem and code context from the main AI agent
            problem_context = ""
            code_context = ""
            
            ai_agent = get_ai_agent()
            if ai_agent and room_id in ai_agent.conversation_history:
                main_context = ai_agent.conversation_history[room_id]
                if main_context.problem_title or main_context.problem_description:
                    problem_context = f"""
Current Problem:
- Title: {main_context.problem_title or "Not specified"}
- Description: {main_context.problem_description or "Not specified"}
- Language: {main_context.programming_language or "Not specified"}
"""
                
                if main_context.code_context:
                    # Show relevant portion of code (first 500 chars)
                    code_snippet = main_context.code_context[:500]
                    if len(main_context.code_context) > 500:
                        code_snippet += "..."
                    code_context = f"""
Current Code:
```{main_context.programming_language or 'python'}
{code_snippet}
```
"""

            prompt = f"""You are a helpful AI programming assistant focused on LEARNING. You are having a private conversation with a user during their pair programming session.

Context: The user is working on a coding problem with their teammate(s). This is a private conversation between you and this specific user - other team members cannot see this chat.
{problem_context}
{code_context}
Conversation History:
{conversation_context}

HELPFUL GUIDANCE APPROACH:
- Give helpful hints and specific tips rather than asking lots of questions
- Point out potential issues or improvements you notice
- Suggest debugging strategies: "Try checking...", "Consider..."
- Provide conceptual explanations and patterns
- Give gentle nudges in the right direction
- Share relevant programming insights or best practices
- Keep responses practical and actionable (1-3 sentences)
- Be naturally helpful while encouraging learning

IMPORTANT RESTRICTIONS:
- DO NOT offer to provide code unless the user explicitly asks for code
- DO NOT say "Would you like some code..." or "Here's some code..."
- DO NOT ask if they want you to write code for them
- Focus on explaining concepts, approaches, and debugging strategies
- Help them think through the problem rather than solving it for them

EXCEPTIONS - When to provide code/documentation:
- When user asks "how to implement..." or "how to use..." - provide documentation and examples
- When user asks for syntax help or language features - show relevant code examples
- When user specifically requests code examples or documentation
- When explaining built-in functions, data structures, or APIs

RESPONSE STYLE:
- Offer specific hints: "The issue might be...", "Consider checking..."
- Point out patterns: "This looks similar to...", "Usually when this happens..."
- Give gentle guidance: "Try...", "You might want to...", "Consider..."
- Share insights: "A common approach is...", "This typically means..."
- Explain concepts: "The key idea here is...", "Think about..."
- Keep responses concise: 15-40 words maximum

Respond to the user's latest message with helpful hints or guidance:"""

            print("Generating individual AI response...", prompt)

            response = self.client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {"role": "system", "content": prompt}
                ],
                max_tokens=150,
                temperature=0.7
            )
            
            return response.choices[0].message.content.strip()

        except Exception as e:
            print(f"âŒ Error generating individual AI response: {e}")
            return None

    def _send_individual_response(self, user_id: str, response: str, original_message_id: str = None):
        """Send AI response to the specific user"""
        self.socketio.emit('individual_ai_response', {
            'userId': user_id,
            'response': response,
            'messageId': original_message_id,
            'timestamp': datetime.now().isoformat()
        })

    def _send_error_response(self, user_id: str, error_message: str):
        """Send error response to the specific user"""
        self.socketio.emit('individual_ai_response', {
            'userId': user_id,
            'response': f"Sorry, {error_message}. Please try again.",
            'isError': True,
            'timestamp': datetime.now().isoformat()
        })

    def clear_individual_conversation(self, user_id: str, room_id: str):
        """Clear conversation history for a specific user in a room"""
        if user_id in self.individual_conversations:
            if room_id in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []
                print(f"ðŸ§¹ Cleared individual conversation for user {user_id} in room {room_id}")

    def clear_room_conversations(self, room_id: str):
        """Clear all individual conversations for a specific room"""
        users_cleared = 0
        for user_id in list(self.individual_conversations.keys()):
            if room_id in self.individual_conversations[user_id]:
                self.individual_conversations[user_id][room_id] = []
                users_cleared += 1
        print(f"ðŸ§¹ Cleared individual AI conversations for {users_cleared} users in room {room_id}")

    def get_conversation_history(self, user_id: str, room_id: str) -> List[Message]:
        """Get conversation history for a specific user in a room"""
        if user_id in self.individual_conversations:
            if room_id in self.individual_conversations[user_id]:
                return self.individual_conversations[user_id][room_id]
        return []

    def handle_user_disconnect(self, user_id: str):
        """Clean up when user disconnects"""
        if user_id in self.individual_conversations:
            # Keep conversation history but could implement cleanup logic here
            print(f"ðŸ‘‹ User {user_id} disconnected from individual AI service")


# Global service instance
individual_ai_service = None

def init_individual_ai_service(socketio_instance):
    """Initialize the individual AI service"""
    global individual_ai_service
    individual_ai_service = IndividualAIService(socketio_instance)
    return individual_ai_service

def get_individual_ai_service():
    """Get the global individual AI service instance"""
    return individual_ai_service
